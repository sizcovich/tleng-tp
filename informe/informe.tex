\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} 
\usepackage[spanish]{babel}
\usepackage{a4wide}
\usepackage{float}
\usepackage{caratula}

\begin{document}

\titulo{Trabajo Práctico}
\subtitulo{SLS: Un simple lenguaje de scripting}

\fecha{\today}

\materia{Teoría de Lenguajes}
\grupo{Los Libres de Contexto}

\integrante{Castro, Alan}{356/10}{alancastro90@gmail.com}
\integrante{Bonomi, Cyntia}{134/03}{cyntiab83@gmail.com}
\integrante{Izcovich, Sabrina}{550/11}{sizcovich@gmail.com}

\maketitle

\tableofcontents

\newpage

\section{Gramática}

En lo que sigue, presentamos la gramática utilizada para la realización del parser:\\

S' $\rightarrow$ program \\ 
program $\rightarrow$ list\_sentencies \\
list\_sentencies $\rightarrow$ NEWLINE a \\
list\_sentencies $\rightarrow$ COMMENT a \\
list\_sentencies $\rightarrow$ sentence a \\
a $\rightarrow$ list\_sentencies \\
a $\rightarrow$ $\lambda$ \\
sentence $\rightarrow$ e SEMICOLON \\
sentence $\rightarrow$ while \\
sentence $\rightarrow$ if\_else \\
sentence $\rightarrow$ for \\
sentence $\rightarrow$ do\_while \\
sentence $\rightarrow$ function SEMICOLON \\
sentence $\rightarrow$ RETURN expression \\
e $\rightarrow$ assignation \\
e $\rightarrow$ advance \\
e $\rightarrow$ ecomparable \\
ecomparable $\rightarrow$ expression \\
ecomparable $\rightarrow$ condition \\
ecomparable $\rightarrow$ conditional \\
possiblecomment $\rightarrow$ COMMENT \\
possiblecomment $\rightarrow$ $\lambda$ \\
comment\_list $\rightarrow$ COMMENT comment\_list \\
comment\_list $\rightarrow$ NEWLINE comment\_list \\
comment\_list $\rightarrow$ $\lambda$ \\
possiblenewline $\rightarrow$ NEWLINE \\
possiblenewline $\rightarrow$ $\lambda$ \\
while $\rightarrow$ WHILE LPAREN condition RPAREN possiblecomment possiblenewline keys \\
if\_else $\rightarrow$ if possibleelse \\
possibleelse $\rightarrow$ ELSE possiblecomment possiblenewline keys \\
if $\rightarrow$ IF LPAREN condition RPAREN possiblecomment possiblenewline keys \\
conditional $\rightarrow$ LPAREN condition RPAREN QUESTIONMARK ecomparable COLON expression \\
possibleelse $\rightarrow$ $\lambda$ \\
conditional $\rightarrow$ condition QUESTIONMARK ecomparable COLON expression \\
for $\rightarrow$ FOR LPAREN assignationorlambda SEMICOLON condition SEMICOLON advancefor RPAREN possiblecomment possiblenewline keys \\
do\_while $\rightarrow$ DO keys\_do WHILE LPAREN condition RPAREN SEMICOLON possiblecomment possiblenewline \\
keys\_do $\rightarrow$ comment\_list sentence possiblenewline \\
keys\_do $\rightarrow$ LKEY possiblenewline possiblecomment list\_sentencies RKEY possiblenewline \\
keys $\rightarrow$ comment\_list sentence possiblenewline \\
keys $\rightarrow$ LKEY possiblenewline possiblecomment list\_sentencies RKEY possiblenewline \\
assignationorlambda $\rightarrow$ assignation \\
assignationorlambda $\rightarrow$ $\lambda$ \\
assignation $\rightarrow$ VAR b \\
b $\rightarrow$ LBRACKET expression RBRACKET ASSIGN expression \\
b $\rightarrow$ ASSIGN ecomparable \\
b $\rightarrow$ COLON ecomparable \\
advancefor $\rightarrow$ advance \\
advancefor $\rightarrow$ assignationorlambda \\
advance $\rightarrow$ VAR c \\
c $\rightarrow$ INCREMENT \\
c $\rightarrow$ PLUSEQUAL value \\
c $\rightarrow$ DECREMENT \\
c $\rightarrow$ MINEQUAL value \\
condition $\rightarrow$ condition OR x \\
condition $\rightarrow$ x \\
x $\rightarrow$ x AND y \\
x $\rightarrow$ y \\
y $\rightarrow$ NOT y \\
y $\rightarrow$ LPAREN condition RPAREN \\
y $\rightarrow$ logical\_condition \\
y $\rightarrow$ value \\
logical\_condition $\rightarrow$ ecomparable i \\
i $\rightarrow$ LESS possibleparen \\
i $\rightarrow$ GREATER possibleparen \\
i $\rightarrow$ EQUAL possibleparen \\
i $\rightarrow$ UNEQUAL possibleparen \\
possibleparen $\rightarrow$ LPAREN ecomparable RPAREN \\
possibleparen $\rightarrow$ ecomparable \\
value $\rightarrow$ STRING \\
value $\rightarrow$ bool \\
value $\rightarrow$ num \\
value $\rightarrow$ function\_with\_return \\
value $\rightarrow$ LBRACKET expression list\_values RBRACKET \\
value $\rightarrow$ LKEY list\_registers RKEY \\
value $\rightarrow$ VAR j \\
j $\rightarrow$ LBRACKET expression RBRACKET \\
j $\rightarrow$ $\lambda$ \\
list\_registers $\rightarrow$ assignation l \\
l $\rightarrow$ COMMA list\_registers \\
list\_values $\rightarrow$ COMMA expression list\_values \\
list\_values $\rightarrow$ $\lambda$ \\
l $\rightarrow$ $\lambda$ \\
expression $\rightarrow$ expression PLUS term \\
expression $\rightarrow$ expression MINUS term \\
expression $\rightarrow$ term \\
term $\rightarrow$ term POW factor \\
term $\rightarrow$ term TIMES factor \\
term $\rightarrow$ term DIVIDE factor \\
term $\rightarrow$ term MODULE factor \\
factor $\rightarrow$ LPAREN expression RPAREN \\
factor $\rightarrow$ value \\
term $\rightarrow$ factor \\
function $\rightarrow$ function\_with\_return \\
function $\rightarrow$ PRINT LPAREN ecomparable RPAREN \\
function\_with\_return $\rightarrow$ MULTIPLICACIONESCALAR LPAREN param\_me RPAREN \\
function\_with\_return $\rightarrow$ CAPITALIZAR LPAREN ecomparable RPAREN \\
function\_with\_return $\rightarrow$ COLINEALES LPAREN VAR COMMA VAR RPAREN \\
function\_with\_return $\rightarrow$ LENGTH LPAREN param\_length RPAREN \\
param\_me $\rightarrow$ VAR COMMA value n \\
n $\rightarrow$ COMMA bool \\
n $\rightarrow$ $\lambda$ \\
param\_length $\rightarrow$ VAR \\
param\_length $\rightarrow$ function\_with\_return \\
param\_length $\rightarrow$ LBRACKET value list\_values RBRACKET \\
param\_length $\rightarrow$ STRING \\
num $\rightarrow$ DECIMAL \\
num $\rightarrow$ NATURAL \\
bool $\rightarrow$ TRUE \\
bool $\rightarrow$ FALSE \\

\newpage
\subsection{Atributos}

Dada la limitación de \textit{PLY} para manejar atributos heredados, todos nuestros atributos son sintetizados.\\

Los atributos con los que contamos son:
\begin{itemize}
\item \textbf{NoTerminal.value}: Consiste en el valor asociado
\item \textbf{NoTerminal.type}: \textit{tipo}. Representa el tipo asociado. El tipo puede ser ``natural'', ``decimal'' o ``string''.
\item \textbf{NoTerminal.isTrue}: \textit{bool}. Almacena la información del booleano dado por parámetro en multiplicacionEscalar.
\item \textbf{NoTerminal.isArray}: \textit{bool}. Guarda la información de si el no terminal deriva en un arreglo o no.
\end{itemize}

\section{Ejemplo de la Gramática de Atributos}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{imgs/ejemploGramatica.png}
\end{center}
\end{figure}

En el diagrama anterior, se pueden observar las derivaciones de una parte del programa presentado a modo de ejemplo.

\section{Conflictos}
Los conflictos shift/reduce fueron resueltos priorizando los shifts por sobre los reduce. En el caso de conflictos generados por el fin de un comentario, éstos fueron siempre resueltos reduciendo $comment\_list$.
\begin{verbatim}
    LKEY            shift and go to state 48
    COMMENT         shift and go to state 52
    NEWLINE         shift and go to state 51
    RETURN          reduce using rule 26 (comment_list -> .)
    WHILE           reduce using rule 26 (comment_list -> .)
    FOR             reduce using rule 26 (comment_list -> .)
    DO              reduce using rule 26 (comment_list -> .)
    PRINT           reduce using rule 26 (comment_list -> .)
    VAR             reduce using rule 26 (comment_list -> .)
    IF              reduce using rule 26 (comment_list -> .)
    MULTIPLICACIONESCALAR reduce using rule 26 (comment_list -> .)
    CAPITALIZAR     reduce using rule 26 (comment_list -> .)
    COLINEALES      reduce using rule 26 (comment_list -> .)
    LENGTH          reduce using rule 26 (comment_list -> .)
    LPAREN          reduce using rule 26 (comment_list -> .)
    NOT             reduce using rule 26 (comment_list -> .)
    STRING          reduce using rule 26 (comment_list -> .)
    LBRACKET        reduce using rule 26 (comment_list -> .)
    TRUE            reduce using rule 26 (comment_list -> .)
    FALSE           reduce using rule 26 (comment_list -> .)
    DECIMAL         reduce using rule 26 (comment_list -> .)
    NATURAL         reduce using rule 26 (comment_list -> .)
\end{verbatim}
\section{Descripción}

Dadas las decisiones tomadas al momento de formular la gramática, consideramos los siguientes casos como incorrectos:

\begin{itemize}
\item Los operadores ternarios no son considerados expresiones, por lo que no permitimos la realización de operaciones aritméticas ni entre strings.
\item No aceptamos *= ni /= , pero sí != y la multiplicación estándar.
\item No aceptamos --f pues no aparecía en el enunciado, pero sí aceptamos f--. Tampoco aceptamos ++ o -- para algo que no sea una variable. 
\item Asumimos que los Registers toman únicamente literales de tipos básicos.
\item x.valor + y.valor representa la concatenación

\item Dado que en los ejemplos no hay enteros negativos decidimos no contemplar ese caso. 
\item No permitimos sentencias separadas en diferentes renglones. Por ejemplo, hacer ``i newline ++'' no lo consideramos válido.
\end{itemize}

Nuestras decisiones fueron tomadas antes de la publicación de los tests dado que el enunciado no especifica explícitamente qué efectuar en esos casos.

Para el resguardo de las variables con sus atributos utilizamos un diccionario \textit{table} donde se almacena la información: \textbf{nombre, tipo, isArray, isTrue} para las variables que así lo requieran para la ejecución de funciones que las utilizan.

\section{Compilación y ejecución}
Para compilar nuestro trabajo práctico y ejecutarlo, alcanza con correr en la consola el siguiente comando:
\textbf{python parser.py archivoEntrada archivoSalida}

\section{Casos de prueba}
Los casos de prueba utilizados fueron los del enunciado, con los que nos aseguramos que se devolviera un error en cuanto la sintáxis no era correcta. Dadas algunas decisiones mencionadas anteriormente, no todos los tests de la cátedra son aceptados por nuestra gramática. En particular, agregamos la carpeta \textbf{test} con los casos de tests subidos por la cátedra con algunas modificaciones para los casos que excluímos.

\section{Conclusión}
Podemos concluir que resulta muy complicado realizar una gramática de tal dimensión sin tener problemas de ambigüedad. A pesar de ello, PLY es una excelente herramienta para dicho fin dado que resuelve los conflictos solucionándole muchos problemas al programador.

\section{Referencias}
\begin{itemize}
\item \textbf{Aho, Sethi, Ullman}, \textit{Compilers: Principles, Techniques, and Tools}, Addison-Wesley, 1986. ISBN 0-201-10088-6

\item \textbf{Python Lex-Yacc} \textit{http://www.dabeaz.com/ply/}
\end{itemize}

\end{document}
