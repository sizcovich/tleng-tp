\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} 
\usepackage[spanish]{babel}
\usepackage{a4wide}
\usepackage{float}
\usepackage{caratula}

\begin{document}

\titulo{Trabajo Práctico}
\subtitulo{SLS: Un simple lenguaje de scripting}

\fecha{\today}

\materia{Teoría de Lenguajes}
\grupo{Los Libres de Contexto}

\integrante{Castro, Alan}{356/10}{alancastro90@gmail.com}
\integrante{Bonomi, Cyntia}{134/03}{cyntiab83@gmail.com}
\integrante{Izcovich, Sabrina}{550/11}{sizcovich@gmail.com}

\maketitle

\tableofcontents

\newpage

\section{Gramática}

En lo que sigue, presentamos la gramática utilizada para la realización del parser:\\

S' $\rightarrow$ program \\ 
program $\rightarrow$ list\_sentencies \\
list\_sentencies $\rightarrow$ NEWLINE a \\
list\_sentencies $\rightarrow$ COMMENT a \\
list\_sentencies $\rightarrow$ sentence a \\
a $\rightarrow$ list\_sentencies \\
a $\rightarrow$ $\lambda$ \\
sentence $\rightarrow$ e SEMICOLON \\
sentence $\rightarrow$ while \\
sentence $\rightarrow$ if\_else \\
sentence $\rightarrow$ for \\
sentence $\rightarrow$ do\_while \\
sentence $\rightarrow$ function SEMICOLON \\
sentence $\rightarrow$ RETURN expression \\
e $\rightarrow$ assignation \\
e $\rightarrow$ advance \\
e $\rightarrow$ ecomparable \\
ecomparable $\rightarrow$ expression \\
ecomparable $\rightarrow$ condition \\
ecomparable $\rightarrow$ conditional \\
possiblecomment $\rightarrow$ COMMENT \\
possiblecomment $\rightarrow$ $\lambda$ \\
comment\_list $\rightarrow$ COMMENT comment\_list \\
comment\_list $\rightarrow$ NEWLINE comment\_list \\
comment\_list $\rightarrow$ $\lambda$ \\
possiblenewline $\rightarrow$ NEWLINE \\
possiblenewline $\rightarrow$ $\lambda$ \\
while $\rightarrow$ WHILE LPAREN condition RPAREN possiblecomment possiblenewline keys \\
if\_else $\rightarrow$ if possibleelse \\
possibleelse $\rightarrow$ ELSE possiblecomment possiblenewline keys \\
if $\rightarrow$ IF LPAREN condition RPAREN possiblecomment possiblenewline keys \\
conditional $\rightarrow$ LPAREN condition RPAREN QUESTIONMARK ecomparable COLON expression \\
possibleelse $\rightarrow$ $\lambda$ \\
conditional $\rightarrow$ condition QUESTIONMARK ecomparable COLON expression \\
for $\rightarrow$ FOR LPAREN assignationorlambda SEMICOLON condition SEMICOLON advancefor RPAREN possiblecomment possiblenewline keys \\
do\_while $\rightarrow$ DO keys\_do WHILE LPAREN condition RPAREN SEMICOLON possiblecomment possiblenewline \\
keys\_do $\rightarrow$ comment\_list sentence possiblenewline \\
keys\_do $\rightarrow$ LKEY possiblenewline possiblecomment list\_sentencies RKEY possiblenewline \\
keys $\rightarrow$ comment\_list sentence possiblenewline \\
keys $\rightarrow$ LKEY possiblenewline possiblecomment list\_sentencies RKEY possiblenewline \\
assignationorlambda $\rightarrow$ assignation \\
assignationorlambda $\rightarrow$ $\lambda$ \\
assignation $\rightarrow$ VAR b \\
b $\rightarrow$ LBRACKET expression RBRACKET ASSIGN expression \\
b $\rightarrow$ ASSIGN ecomparable \\
b $\rightarrow$ COLON ecomparable \\
advancefor $\rightarrow$ advance \\
advancefor $\rightarrow$ assignationorlambda \\
advance $\rightarrow$ VAR c \\
c $\rightarrow$ INCREMENT \\
c $\rightarrow$ PLUSEQUAL value \\
c $\rightarrow$ DECREMENT \\
c $\rightarrow$ MINEQUAL value \\
condition $\rightarrow$ condition OR x \\
condition $\rightarrow$ x \\
x $\rightarrow$ x AND y \\
x $\rightarrow$ y \\
y $\rightarrow$ NOT y \\
y $\rightarrow$ LPAREN condition RPAREN \\
y $\rightarrow$ logical\_condition \\
y $\rightarrow$ value \\
logical\_condition $\rightarrow$ ecomparable i \\
i $\rightarrow$ LESS possibleparen \\
i $\rightarrow$ GREATER possibleparen \\
i $\rightarrow$ EQUAL possibleparen \\
i $\rightarrow$ UNEQUAL possibleparen \\
possibleparen $\rightarrow$ LPAREN ecomparable RPAREN \\
possibleparen $\rightarrow$ ecomparable \\
value $\rightarrow$ STRING \\
value $\rightarrow$ bool \\
value $\rightarrow$ num \\
value $\rightarrow$ function\_with\_return \\
value $\rightarrow$ LBRACKET expression list\_values RBRACKET \\
value $\rightarrow$ LKEY list\_registers RKEY \\
value $\rightarrow$ VAR j \\
j $\rightarrow$ LBRACKET expression RBRACKET \\
j $\rightarrow$ $\lambda$ \\
list\_registers $\rightarrow$ assignation l \\
l $\rightarrow$ COMMA list\_registers \\
list\_values $\rightarrow$ COMMA expression list\_values \\
list\_values $\rightarrow$ $\lambda$ \\
l $\rightarrow$ $\lambda$ \\
expression $\rightarrow$ expression PLUS term \\
expression $\rightarrow$ expression MINUS term \\
expression $\rightarrow$ term \\
term $\rightarrow$ term POW factor \\
term $\rightarrow$ term TIMES factor \\
term $\rightarrow$ term DIVIDE factor \\
term $\rightarrow$ term MODULE factor \\
factor $\rightarrow$ LPAREN expression RPAREN \\
factor $\rightarrow$ value \\
term $\rightarrow$ factor \\
function $\rightarrow$ function\_with\_return \\
function $\rightarrow$ PRINT LPAREN ecomparable RPAREN \\
function\_with\_return $\rightarrow$ MULTIPLICACIONESCALAR LPAREN param\_me RPAREN \\
function\_with\_return $\rightarrow$ CAPITALIZAR LPAREN ecomparable RPAREN \\
function\_with\_return $\rightarrow$ COLINEALES LPAREN VAR COMMA VAR RPAREN \\
function\_with\_return $\rightarrow$ LENGTH LPAREN param\_length RPAREN \\
param\_me $\rightarrow$ VAR COMMA value n \\
n $\rightarrow$ COMMA bool \\
n $\rightarrow$ $\lambda$ \\
param\_length $\rightarrow$ VAR \\
param\_length $\rightarrow$ function\_with\_return \\
param\_length $\rightarrow$ LBRACKET value list\_values RBRACKET \\
param\_length $\rightarrow$ STRING \\
num $\rightarrow$ DECIMAL \\
num $\rightarrow$ NATURAL \\
bool $\rightarrow$ TRUE \\
bool $\rightarrow$ FALSE \\

\newpage
\subsection{Atributos}

Dada la limitación de \textit{PLY} para manejar atributos heredados, todos nuestros atributos son sintetizados.\\

Los atributos con los que contamos son:
\begin{itemize}
\item \textbf{NoTerminal.value}: Consiste en el valor asociado
\item \textbf{NoTerminal.type}: \textit{tipo}. Representa el tipo asociado. Para ver los tipos posibles ver sección 4.2
\item \textbf{NoTerminal.isTrue}: \textit{bool}. Almacena la información del booleano dado por parámetro en multiplicacionEscalar.
\item \textbf{NoTerminal.stringInterno}: \textit{string}. Sirve para obtener al tipo correspondiente cuando se requiere el tipo de un elemento que se encuentra en una posicion de un array o el tipo de un atributo de un registro.
\item \textbf{NoTerminal.isPlusEqual}: \textit{bool}. Posee la información de si el operador aplicado es +=
\item \textbf{NoTerminal.line}: \textit{int}. Posee la información de la linea donde ocurre la sentencia en el texto original.
\item \textbf{NoTerminal.dict}: \textit{dict}. ???
\end{itemize}

\section{Ejemplo de la Gramática de Atributos}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{imgs/ejemploGramatica.png}
\end{center}
\end{figure}

En el diagrama anterior, se pueden observar las derivaciones de una parte del programa presentado a modo de ejemplo.

\section{Conflicto}
Nuestro conflicto se presenta en el \textbf{ELSE} en el siguiente caso:

\begin{verbatim}
sentence -> IF LPAREN expression RPAREN keys . possibleelse
possibleelse -> . ELSE keys
possibleelse -> .


! shift/reduce conflict for ELSE resolved as shift

\end{verbatim}


Consiste en un conflicto de tipo shift/reduce introducido por la ambiguedad que presenta la gramatica para ese caso.
Llega un momento donde el parser no sabe si debe shiftear o reducir. Sin embargo toma la decisión correcta, es decir, si en la entrada tiene un ELSE shiftea, de lo contrario reduce.

Es posible desambiguar la gramática (puede verse en 4.3.2 Eliminación de la ambigüedad en el libro Aho, Sethi, Ullman: Compilers: Principles, Techniques, and Tools, Addison Wesley), sin embargo, por ser un conflicto permitido por la cátedra, usamos la forma ambigua.

\section{Descripción}

\subsection{Operaciones no permitidas}


Si tenemos un registro dentro de algun arreglo, no son validas las expresiones del tipo
array[i].atributo

Por ejemplo, si tenemos

\begin{verbatim}
usuarios = [{nombre:"Mr.X", edad:10}, {nombre:"Al", edad:50}];
edad = usuarios[i].edad;
\end{verbatim}

no permitimos la operación usuarios[i].edad

Realizar esa operación, requiere un cambio en la gramática a la hora de "generar" variables. La cual no contemplamos desde un principio debido a que decidimos utilizar tipos básicos.
Sin embargo realizar esta modificación, considerando que ya tenemos todas las estructuras de tipos armadas, no requeriría un gran esfuerzo.

 
Debido a esta decisión, los tests regs.i y all.i no funcionan enteros. 


\subsection{Estructura de tipos}

Para el resguardo de las variables con sus atributos utilizamos un diccionario \textit{table} donde se almacena la información: 

\begin{verbatim}

Registros:
nombreVariable: { "tipo": "register", "dict": unDicc}

Arreglos
nombreVariable: { "tipo": "array", "dict": unDicc}

Tipos basicos (booleanos, strings, naturales, negativos, decimales)
nombreVariable: { "tipo": "tipoBasico", "dict": None}


Ejemplos: 

1)

numeros = [[1, 2], [3]]


Datos en la tabla de tipos:

{"numeros": { "tipo": "array", "tipoInterno": 
							     {"tipo": "array","tipoInterno":
												     {"tipo": "natural", "tipoInterno":None}
								 }
			}
}
2)

persona = { nombre : "juan", edad : 25 , padres: { mama: "maria", papa: "luis"}}

Datos en la tabla de tipos:

{"persona": 
	{"tipo" : "register",
  	 "tipoInterno":{"nombre":{"tipo":"string","tipoInterno": None},
                  	"edad":  {"tipo":"natural","tipoInterno": None},
                  	"padres":{"tipo":"register","tipoInterno":
                                              {"mama": {"tipo":"string", "tipoInterno": None},
                                               "papa": {"tipo":"string", "tipoInterno": None}  												  }
                   }
     }
 }


\end{verbatim}
\section{Compilación y ejecución}
Para compilar nuestro trabajo práctico y ejecutarlo, alcanza con correr en la consola el siguiente comando:
\textbf{./SLSparser.py -o archivoSalida -c archivoEntrada} 
Los parámetros son opcionales. Por default, la entrada y salida son la consola en el caso en el que no se especifique alguno de los archivos.
Al pasar un programa por stdin, la finalización del mismo se indica a través del comando \textit{ctrl+d}

\section{Casos de prueba}
Los casos de prueba utilizados fueron los del enunciado, con los que nos aseguramos que se devolviera un error en cuanto la sintáxis no era correcta. Dadas algunas decisiones mencionadas anteriormente, no todos los tests de la cátedra son aceptados por nuestra gramática. En particular, agregamos la carpeta \textbf{test} con los casos de tests subidos por la cátedra con algunas modificaciones para los casos que excluímos.

\section{Conclusión}
Podemos concluir que resulta muy complicado realizar una gramática de tal dimensión sin tener problemas de ambigüedad. A pesar de ello, PLY es una excelente herramienta para dicho fin dado que resuelve los conflictos solucionándole muchos problemas al programador.

\section{Referencias}
\begin{itemize}
\item \textbf{Aho, Sethi, Ullman}, \textit{Compilers: Principles, Techniques, and Tools}, Addison-Wesley, 1986. ISBN 0-201-10088-6

\item \textbf{Python Lex-Yacc} \textit{http://www.dabeaz.com/ply/}
\end{itemize}

\end{document}
